#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t reveal_title_slide:nil reveal_slide_number:nil reveal_progress:t reveal_history:t reveal_center:t
#+REVEAL_THEME: solarized

-- three hundred and sixty minutes

* ⚗️ELIXIR! ⚗️
:PROPERTIES:
:TIME: 0 minutes
:END:
λ conf 2017 workshop
* "Aldric!"
:PROPERTIES:
:TIME: 1 minutes
:END:
That's me.

Yell that when you're stuck.

Send flames to /dev/null.
* Getting in groups and group intros
:PROPERTIES:
:TIME: 5 minutes
:END:

Get in groups of four.
Prefer people you don't know.
- Your name
- How you like to receive help
- Your familiarity with functional programming

* How this is gonna go down
:PROPERTIES:
:TIME: 1 minutes
:END:
- 3x(25 minutes of work + 5-minute break)
- 15-minute break
- rinse and repeat
- also, food somewhere
* Getting familiar with codio
:PROPERTIES:
:TIME: 5 minutes
:END:
- log in
- set up Elixir VM
* The documentation
:PROPERTIES:
:TIME: 1 minutes
:END:
Teach a 👤 to 🐟 ...

https://hexdocs.pm/elixir/Kernel.html#content

This will likely come in handy.
* REPL work
:PROPERTIES:
:TIME: 25 minutes
:END:
** Entering the repl
=iex= on the command line.
#+BEGIN_SRC
$ iex
Erlang/OTP 19 [erts-8.3] [source] [64-bit] [smp:8:8]
  [async-threads:10] [hipe] [kernel-poll:false] [dtrace]

Interactive Elixir (1.4.2) - press Ctrl+C to exit (type h() ENTER for help)
iex(1)>
#+END_SRC
** Data structures
- numbers
- strings (interpolation)
- ranges
- maps
- lists
** Console interface, get and put
- =IO.puts foo=
- =IO.inspect foo=
- =input = IO.gets("Your input ")=
** List comprehensions
The Enum module has most of the functions you care about:
- =Enum.member?=
- =Enum.map=
- =Enum.flat_map=
- =Enum.reduce=
** Anonymous functions
#+BEGIN_SRC elixir
foo = fn() -> 5 end
foo.()
sum = fn(x, y) -> x + y end
sum.(2, 3)
sum = &(&1 + &2)
sum.(2, 3)
#+END_SRC
** Modules, aka namespaces
#+BEGIN_SRC elixir
defmodule Foo do
  @static_number 100
end
#+END_SRC
** Named functions
#+BEGIN_SRC elixir
defmodule Foo do
  def double_numbers(list) do
    Enum.map(list, fn(x) -> x * 2 end)
  end

  def bar do
    myfunc([1,2,3])
  end
end

Foo.bar()
#+END_SRC
** REPL / mapping Exercises
*** Each
Take this data structure and create the following output:
#+BEGIN_SRC elixir
  beatles = ["john", "paul", "george", "ringo", "stu"]

  # output:
  #=> 'john fondly remembers doing amphetamines in Hamburg'
  #=> 'paul fondly remembers doing amphetamines in Hamburg'
  #=> 'george fondly remembers doing amphetamines in Hamburg'
  #=> 'ringo fondly remembers doing amphetamines in Hamburg'
  #=> 'stu fondly remembers doing amphetamines in Hamburg'
#+END_SRC
*** Map
Take this data structure and create the following output:
#+BEGIN_SRC elixir
beatles = ["john", "paul", "george", "ringo", "stu"]

# output:
#=> ["John", "Paul", "George", "Ringo", "Stu"]
#+END_SRC
*** Squares and Hash
Write code that:
- Prompts the user for a minimum and maximum number.
- Generates a Hash that has key-value pairs, or entries, where.
  - Each key in a pair is a integer between the min and max entered.
  - Each value in the pair is the square of key in that pair.

#+BEGIN_SRC elixir
# with a min and max of 2 and 4, respectively, the resulting hash would be:
a = %{1=>1, 2=>4, 3=>9}
#+END_SRC
* BREAK
* recursion, pattern matching, pipeline
** Pattern matching
#+BEGIN_SRC elixir
defmodule Foo do
  def bar(1) do
    IO.puts "hey hey"
  end
  def bar(2) do
    IO.puts "yah yah"
  end
end
#+END_SRC
** Recursion
Just pattern matching. Function definition order may matter.
#+BEGIN_SRC elixir
defmodule Foo do
  def recurse([], acc) do
    IO.puts acc
  end

  def recurse(list) do
    recurse(list, 0)
  end

  def recurse([head | tail], acc) do
    recurse(tail, acc + head)
  end
end
#+END_SRC
** Fibonacci
Write recursive code that computes a Fibonacci number.
The Fibonacci series is defined as:

- n(x) where x < 1 = undefined
- n(1) = 1
- n(2) = 1
- n(x) = n(x-1) + n(x+2)
** Fizzbuzz exercise
Write a program that prints the numbers from 1 to 100. But for multiples of three print "Fizz" instead of the number and for the multiples of five print "Buzz". For numbers which are multiples of both three and five print "FizzBuzz".
* BREAK
* Pipeline
#+BEGIN_SRC elixir
(1..100)
|> Enum.filter(fn(x) -> rem(x, 2) == 0 end) # Modulo operator!
|> Enum.map(fn(x) -> x * 2 end)
#+END_SRC
* The =with= keyword
* GenServers
* Creating a project

* Guess the number
#+BEGIN_SRC elixir
defmodule Guess do
  def start do
    number = Enum.random(1..10)
    loop_guessing(number)
  end

  def loop_guessing(number) do
    guess =
      IO.gets("Your guess: ")
      |> String.trim
      |> String.to_integer
    evaluate_guess(guess, number)
  end

  def evaluate_guess(guess, number) when guess < number do
    IO.puts "You guessed too low!"
    loop_guessing(number)
  end

  def evaluate_guess(guess, number) when guess > number do
    IO.puts "You guessed too high!"
    loop_guessing(number)
  end

  def evaluate_guess(guess, number) when guess == number do
    IO.puts "You guessed right!"
  end
end
#+END_SRC

* The = operator
Acts as both assignment and pattern-matching operator.
- a = 5 # ⇒ 5 (assignment)
- 5 = a # ⇒ 5 (pattern match)
- 6 = a # ⇒ MatchError
- ^a = 5 # ⇒ 5 (pattern match)
- ^a = 6 # ⇒ MatchError
Significantly less of a problem than one thinks it might becomes.
